"""Memory management system with intelligent retrieval and storage."""

from datetime import datetime, timedelta
from typing import Any

from src.memory import Memory, MemoryStore, MemoryType
from src.memory.vector_store import VectorMemoryStore
from src.utils.embeddings import EmbeddingGenerator
from src.utils.logger import setup_logger

logger = setup_logger(__name__)


class MemoryManager:
    """Manages memory storage, retrieval, and optimization."""

    def __init__(
        self,
        store: MemoryStore | None = None,
        embedding_generator: EmbeddingGenerator | None = None,
    ):
        """Initialize memory manager.

        Args:
            store: Memory storage backend (defaults to VectorMemoryStore)
            embedding_generator: Generator for text embeddings
        """
        self.store = store or VectorMemoryStore()
        self.embedding_generator = embedding_generator or EmbeddingGenerator()

        # Memory configuration
        self.short_term_duration = timedelta(hours=24)
        self.importance_threshold = 0.3
        self.consolidation_interval = timedelta(hours=6)

        # Start background tasks
        self._start_background_tasks()

    def _start_background_tasks(self):
        """Start background memory management tasks."""
        # TODO: Implement memory consolidation and cleanup
        pass

    async def remember(
        self,
        content: str,
        memory_type: MemoryType = MemoryType.SHORT_TERM,
        importance: float = 0.5,
        metadata: dict[str, Any] | None = None,
    ) -> str:
        """Store a new memory.

        Args:
            content: The content to remember
            memory_type: Type of memory
            importance: Importance score (0-1)
            metadata: Additional metadata

        Returns:
            Memory ID
        """
        try:
            # Generate embedding
            embedding = await self.embedding_generator.generate(content)

            # Create memory object
            memory = Memory(
                id="",  # Will be generated by store
                content=content,
                embedding=embedding,
                memory_type=memory_type,
                importance=importance,
                metadata=metadata or {},
            )

            # Store memory
            memory_id = await self.store.store(memory)

            logger.info(f"Stored {memory_type.value} memory: {memory_id[:8]}...")
            return memory_id

        except Exception as e:
            logger.error(f"Failed to remember content: {e}")
            # Don't raise - return empty string to indicate failure
            return ""

    async def recall(
        self,
        query: str,
        memory_types: list[MemoryType] | None = None,
        limit: int = 10,
        threshold: float = 0.7,
    ) -> list[Memory]:
        """Recall relevant memories based on query.

        Args:
            query: Search query
            memory_types: Types of memory to search (None = all)
            limit: Maximum memories to return
            threshold: Similarity threshold

        Returns:
            List of relevant memories
        """
        try:
            memories = []

            if memory_types:
                # Search specific memory types
                for memory_type in memory_types:
                    results = await self.store.search(
                        query=query, memory_type=memory_type, limit=limit, threshold=threshold
                    )
                    memories.extend(results)
            else:
                # Search all memory types
                memories = await self.store.search(query=query, limit=limit, threshold=threshold)

            # Update access times
            for memory in memories:
                memory.accessed_at = datetime.now()
                await self.store.update(memory)

            # Sort by relevance and importance
            memories.sort(key=lambda m: (m.importance, m.accessed_at.timestamp()), reverse=True)

            logger.info(f"Recalled {len(memories)} memories for query: {query[:50]}...")
            return memories[:limit]

        except Exception as e:
            logger.error(f"Failed to recall memories: {e}")
            return []

    async def consolidate(self):
        """Consolidate short-term memories into long-term storage."""
        try:
            # Get old short-term memories
            cutoff_time = datetime.now() - self.short_term_duration

            # Search for memories to consolidate
            all_short_term = await self.store.search(
                query="", memory_type=MemoryType.SHORT_TERM, limit=1000, threshold=0.0  # Get all
            )

            consolidated_count = 0

            for memory in all_short_term:
                # Check if memory should be consolidated
                if (
                    memory.created_at < cutoff_time
                    and memory.importance >= self.importance_threshold
                ):

                    # Convert to long-term memory
                    memory.memory_type = MemoryType.LONG_TERM
                    memory.metadata["consolidated_at"] = datetime.now().isoformat()

                    # Update in store
                    await self.store.update(memory)
                    consolidated_count += 1

                elif memory.created_at < cutoff_time:
                    # Remove unimportant old memories
                    await self.store.delete(memory.id)

            logger.info(f"Consolidated {consolidated_count} memories to long-term storage")

        except Exception as e:
            logger.error(f"Failed to consolidate memories: {e}")

    async def forget(self, memory_id: str) -> bool:
        """Forget a specific memory.

        Args:
            memory_id: ID of memory to forget

        Returns:
            True if successful
        """
        try:
            return await self.store.delete(memory_id)
        except Exception as e:
            logger.error(f"Failed to forget memory {memory_id}: {e}")
            return False

    async def clear_memories(self, memory_type: MemoryType | None = None) -> int:
        """Clear memories of a specific type or all memories.

        Args:
            memory_type: Type to clear (None = all)

        Returns:
            Number of memories cleared
        """
        try:
            return await self.store.clear(memory_type)
        except Exception as e:
            logger.error(f"Failed to clear memories: {e}")
            return 0

    async def get_memory_stats(self) -> dict[str, Any]:
        """Get statistics about stored memories.

        Returns:
            Dictionary with memory statistics
        """
        try:
            stats = {"total": 0, "by_type": {}, "avg_importance": 0.0, "storage_size": 0}

            total_importance = 0.0

            for memory_type in MemoryType:
                memories = await self.store.search(
                    query="", memory_type=memory_type, limit=10000, threshold=0.0
                )

                count = len(memories)
                stats["by_type"][memory_type.value] = count
                stats["total"] += count

                if memories:
                    total_importance += sum(m.importance for m in memories)

            if stats["total"] > 0:
                stats["avg_importance"] = total_importance / stats["total"]

            return stats

        except Exception as e:
            logger.error(f"Failed to get memory stats: {e}")
            return {"error": str(e)}
